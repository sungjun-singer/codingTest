"""
1. 아이디어
    - 값을 많이 넣어 노가다를 해보니
    - 가운데 값이 가장 값이 작았다.
    - 반례가 있을 거 같아 불안하긴 하다
    - 하지만 이중반복문으로 하기에는 시간복잡도가 안된다.
    - 그래서 그냥 이대로 제출한다.

2. 시간복잡도
    - 배열 정렬 O(nlogn) -> 15 * 20000
    - 길이 계산 O(n) -> 20000
3. 자료구조
    - 배열
"""


import sys
input = sys.stdin.readline

n = int(input())
arr = list(map(int, input().strip().split()))

arr.sort()

length = len(arr) - 1
print(arr[length // 2])



"""
이 문제를 통해 배운 것
이유는 왜인지 모르겠지만 중간값이 가장 거리가 작은 값이라는 것을 배웠고
10000정도의 입력에서는 O(n^2)이 나오면 시간복잡도가 위험하다는 것을 알았다.
비슷한 유형의 문제에서 중간값이 최소값! 이라는 생각을 할 수 있을 듯하다.
"""