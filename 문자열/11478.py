"""
1. 아이디어
- 배열에 부분 문자열을 다 저장한다.
    - 이중반복문으로 하는데, 문자열의 길이(n)만큼 반복문을 돌리는 데 이때 인덱스를 i로 둔다
    - 두번째 반복문은 j로 돌리는데 반복횟수를 n-i로 설정한다.
    - 왜냐하면 3개의 부분 문자열을 구한다고 하면 0번 인덱스부터 n-2번까지 구하면 되기 때문에
- Set을 통해 중복을 제거하고 개수를 센다.

2. 시간복잡도
- 배열에 부분 문자열을 다 저장 -> O(n^2) -> 1000 * 1000 -> 1,000,000
- Set을 통한 배열의 중복 제거 -> O(n) -> 1,000,000 (배열의 개수가 1,000,000개 이기 때문)
- 총 시간 복잡도 1,000,000 + 1,000,000 = 2,000,000 -> 가능

3. 자료구조
- String [] arr
- Set {}
"""

import sys
input = sys.stdin.readline

S = input()
n = len(S)
arr = []

# 1~n까지 반복
for i in range(1, n+1):
    # 0부터 n-i까지 반복
    for j in range(n-i):
        # print("i = ", i, "j =", j, "S[j:j+i] =", S[j:j+i])
        # S[a:b] -> S의 a부터 b-1까지의 문자열 반환
        arr.append(S[j:j+i])

# print(arr)
set1 = set(arr)
print(len(set1))

"""
이번문제를 통해 공부한 것
- 중복제거를 통해 set을 사용할 수 있고
- 이때의 시간 복잡도는 O(n)이다.
- 파이썬의 set은 해시테이블 기반의 자료구조이다.
- 그래서 배열의 요소 하나씩 돌면서 hash값을 연산하고 해당 값이 가리키는 버킷을 찾고
- 버킷이 비어있으면 추가하고 같은 값이 이미 존재하면 추가하지 않는다.
- 결론은, 배열을 한번만 돌기 때문에 O(n)이 걸린다.
"""